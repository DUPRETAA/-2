#include <iostream>
#include <iomanip> //библитека, подключена для вывода бОльшего количесьва знаков после запятой
#include <cmath>

using namespace std;

double Epsilon = 0.000001; // точность эпсилонк, с которой будет найден приближенный корень
double x0 = 2; // корни, с которыми будет происходить взаимодействие (начальное значение взято вне основного отрезка для отладки и работы условий в дальнейшем
double x1 = 2;
double buffer; // переменная для временного хранения значений


double equation(double x) // функция, возвращающая значение функции согласно варианту
{
    x = (sqrt(1 - 0.4 * pow(x, 2)) - asin(x));
    return x;
}

void out() // процедура вывода результата промежуточных вычислений
{
    cout << "x1 = " << setprecision(10) << x1 << endl;
    cout << "x0 = " << setprecision(10) << x0 << endl;
}

void NewtonMethod() // метод Ньютона (метод касательных)
{
    while (x0 >= 1 || x0 <= 0)
    {
        cout << "Введите произвольную точку на отрезке (0;1)" << endl;
        cin >> x0;
    }
    do
    {
        if (x1 != 2) x0 = x1; // подстановка раннее найденного корня, со второго прохода цикла
        x1 = x0 - equation(x0) / ( - ((2 * x0) / (5 * sqrt(1 - ((2 * x0 * x0) / 5)))) - (1 / (sqrt(1 - x0 * x0)))); // нахождение следующего корня, согласно формуле
        out(); // вывод промежууточных значений
    } while (fabs(x0 - x1) > Epsilon); // проверка на соответствие корня заданной погрешности

    cout << "Корень уравнения: " << setprecision(10) << x1 << endl << endl; // вывод найденного корня

    x0 = 2; // "обнуление" корней
    x1 = 2;
}

void DivisionMethod() // метод половинного деления
{
    x0 = 1; // устанавливаем приближенные корни на начало и конец отрезка, содержащий корень кравнения
    x1 = 0;

    while (fabs(equation(x0) - equation(x1)) > Epsilon) // проверка на соответствие точности полученного корня
    {
        if (equation(x0) * equation(x1) < 0) // проверка, лежит ли точный корень в пределах текущего интервала
        {
            x1 += (x0 - x1) / 2; // сдвигаем нижнюю границу на пол интервала вверх (слева направо на оси Ох)
        }
        else
        {
            buffer = x1; // сохраняем значение нижней границы интервала
            x1 -= (x0 - x1) / 2; // если корень не лежит в границах текущего интервала, за верхнее знчение принимаем нижнюю границу, а нижнюю границу принимаем как половину разности текущих границ по модулю
            x0 = buffer; // присваиваем значение ранее сохраненной нижней границы
        }

        out();
    }

    cout << "Корень уравнения: " << setprecision(10) << x1 << endl << endl; // вывод найденного корня
    
    x0 = 2; // "обнуление" корней
    x1 = 2;
}

void IterationMethod() // итерационный метод
{
    while (x0 > 1 || x0 < 0) // цикл на выбор начальной точки
    {
        cout << "Введите произвольную точку на отрезке [0;1]" << endl;
        cin >> x0;
        if (fabs((2*x0*cos(sqrt(1-((2*pow(x0,2))/5))) / (5* sqrt(1 - ((2 * pow(x0, 2)) / 5))))*-1) > 1) // проверка на сходиомсть
        {
            cout << "Сходимость не соблюдается, выберите другое значение";
            x0 = 2;
        }
    
    }
    do
    {
        if (x1 != 2) x0 = x1; // сохраняем найденный корень для дальнейших вычислений (со второго прохода)
        x1 = sin(sqrt(1-0.4*pow(x0,2))); // вычисляем новое значение с помощью вспомогательной функции
        out(); // вывод промежуточных значений
    } while (fabs(x0 - x1) > Epsilon);

    cout << "Корень уравнения: " << setprecision(10) << x1 << endl << endl; // вывод приближенного корня в пределах установленной точности

    x0 = 2; // "обнуление" корней
    x1 = 2;
}



int main()
{
    
    int switcher;

    setlocale(LC_ALL, "RU");

    while (true)
    {
        cout << "Выберите метод решения нелинейного уравнения: 1 - метод Ньютона, 2 - метод половинного деления, 3 - метод итераций, 0 - выход" << endl;
        cin >> switcher;
        switch (switcher)
        {
        case 1: NewtonMethod(); break;
        case 2: DivisionMethod(); break;
        case 3: IterationMethod(); break;
        case 0: return 0;
        }

    }
}


